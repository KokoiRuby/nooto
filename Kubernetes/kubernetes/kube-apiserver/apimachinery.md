## [API Machinery](https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/apimachinery)

A lib for Scheme, typing, encoding, decoding, and conversion packages for Kubernetes and Kubernetes-like API objects.

### Recap

TypeMeta → **GVK (Group/Version/Kind)** as unique identity of Resource Model/Object in K8s.

**Verson**: (multi) External → Internal betore persisting into etcd via **convertFunc** (to achieve backward compatible).

### [Src](https://github.com/kubernetes/kubernetes/tree/master)

`register.go` defines GV, SchemeBuilder then reg GVK into scheme, otherwise won't be read from API server.

```go
// pkg/apis/core/register.go
const GroupName = ""
var SchemeGroupVersion = schema.GroupVersion{Group: GroupName, Version: runtime.APIVersionInternal}

SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)
AddToScheme = SchemeBuilder.AddToScheme

func addKnownTypes(scheme *runtime.Scheme) error {
	if err := scheme.AddIgnoredConversionType(&metav1.TypeMeta{}, &metav1.TypeMeta{}); err != nil {
		return err
	}
	scheme.AddKnownTypes(SchemeGroupVersion,
		&Pod{},
		&PodList{},
    ...                 
```

`types.go` defines king/type struct.

- Single
  - TypeMeta
  - ObjectMeta
  - Spec
  - Status
- List
  - TypeMeta
  - ListMeta
  - Spec
  - Status

```go
// api/core/v1/types.go (external) with json & protobuf tag
// ↑ 
// conversion
// ↓
// pkg/apis/core/types.go (internal)
```

### CodeGen

Read by [code-generator](https://github.com/kubernetes/code-generator) to gen code & lib.

Global: `// +k8s:deepcopy-gen=package` in `doc.go` effective for package, gen deep-copy for all types.

Local: `// +genclient*` in `types.go`

[cmd](https://github.com/kubernetes/code-generator/tree/master/cmd):

- **deepcopy-gen**: deep copy method for obj to create complete replica.
- **client-gen**: create clientSet for obj CRUD.
- **informer-gen**: for watching obj.
- **lister-gen**: get/lister to build client cache
- **coversion-gen**: convertFunc.

```go
import {
    "k8s.io/api/core/v1"
}

// deep copy
p := v1.Pod{}
p.DeepCopy()

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Pod.
func (in *Pod) DeepCopy() *Pod {
	if in == nil {
		return nil
	}
	out := new(Pod)
	in.DeepCopyInto(out)
	return out
}
```

### Storage

`storage.go` persist to etcd

```go
func NewREST(optsGetter generic.RESTOptionsGetter) (*REST, error) {
	store := &genericregistry.Store{
		NewFunc:                   func() runtime.Object { return &api.ConfigMap{} },
		NewListFunc:               func() runtime.Object { return &api.ConfigMapList{} },
		PredicateFunc:             configmap.Matcher,
		DefaultQualifiedResource:  api.Resource("configmaps"),
		SingularQualifiedResource: api.Resource("configmap"),
		
        // actions when verb on 
		CreateStrategy: configmap.Strategy,
		UpdateStrategy: configmap.Strategy,
		DeleteStrategy: configmap.Strategy,

		TableConvertor: printerstorage.TableConvertor{TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)},
	}
    // API Server RingBuffer cache entry
	options := &generic.StoreOptions{
		RESTOptions: optsGetter,
		AttrFunc:    configmap.GetAttrs,
	}
	if err := store.CompleteWithOptions(options); err != nil {
		return nil, err
	}
	return &REST{store}, nil
}
```

```go
func (strategy) PrepareForCreate(ctx context.Context, obj runtime.Object) {
	configMap := obj.(*api.ConfigMap)
	dropDisabledFields(configMap, nil)
}

func (strategy) Validate(ctx context.Context, obj runtime.Object) field.ErrorList {
	cfg := obj.(*api.ConfigMap)

	return validation.ValidateConfigMap(cfg)
}

func (strategy) PrepareForCreate(ctx context.Context, obj runtime.Object) {
	configMap := obj.(*api.ConfigMap)
	dropDisabledFields(configMap, nil)
}
```

### subresource

inside K8s API object, like **status**, managed separately/independently

```go
// pkg/registry/core/pod/strategy.go
func (podStrategy) PrepareForUpdate(ctx context.Context, obj, old runtime.Object) {
	newPod := obj.(*api.Pod)
	oldPod := old.(*api.Pod)
	newPod.Status = oldPod.Status

	if utilfeature.DefaultFeatureGate.Enabled(features.InPlacePodVerticalScaling) {
		podutil.MarkPodProposedForResize(oldPod, newPod)
	}

	podutil.DropDisabledPodFields(newPod, oldPod)
}

func (podStatusStrategy) PrepareForUpdate(ctx context.Context, obj, old runtime.Object) {
	newPod := obj.(*api.Pod)  // incoming req
	oldPod := old.(*api.Pod)  // etcd
	newPod.Spec = oldPod.Spec // keep spec, avoid spec write conflict
	newPod.DeletionTimestamp = nil
 
	newPod.OwnerReferences = oldPod.OwnerReferences
}
```

```go
// pkg/registry/core/rest/storage_core_generic.go

// define storage
configMapStorage, err := configmapstore.NewREST(restOptionsGetter)

// define obj StorageMap
if len(storage) > 0 {
	apiGroupInfo.VersionedResourcesStorageMap["v1"] = storage
}

// pkg/controlplane/apiserver/apis.go
// reg obj into API Server
if len(groupName) == 0 {
	if err := s.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &apiGroupInfo); err != nil {
		return fmt.Errorf("error in registering legacy API: %w", err)
	}
} else {
	// everything else goes to /apis
	nonLegacy = append(nonLegacy, &apiGroupInfo)
}
```